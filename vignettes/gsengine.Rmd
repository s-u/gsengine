---
title: "Using gs.engine(): Genstat Socket Engine"
author: "Yuxiao Wang, James Curran, Simon Urbanek"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
  toc: true
  fig_caption: true
vignette: >
  %\VignetteIndexEntry{Using gs.engine(): Genstat Socket Engine}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{css, echo = FALSE}
img {
    max-width: 50%;  
    height: auto; 
}
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```



## Overview
This vignette demonstrates how to use the `gs.engine` function provided by the `gsengine` package to run Genstat code chunks from within an R Markdown document.

It assumes:

  * You have a Genstat licence
  * A *listening programme*---Genstat messenger is already running and accessible, either locally, or over a socket connection
  
## Using `gsengine` with Genstat on your own machine
If you have Genstat installed locally, i.e. on the machine that you are writing your R Markdown document, then you can create a `knitr` engine for interacting with Genstat by using the `gs.engine` function from the `gsengine` package with the `knitr::knit_engines$set` function. That is, you create an R chunk that calls the `knitr::knit_engines$set` function

    ```{r}
    knitr::knit_engines$set(gs = gsengine::gs.engine())
    ```
Note that there is nothing special about the `gs` variable. All it allows you to do is tell R Markdown that the chunk should talk to Genstat in order to interpret the code. That is if you specify a chunk with

    ```{gs}
    
    ```
then R Markdown knows to talk to the Genstat engine. We could have used the name `Genstat`, `g`, or any other valid variable name and it would work in the same way. We will use `gs` throughout this document.

## Interacting with Genstat remotely
One of the cool things about how David Baird and Simon Urbanek wrote the Genstat Messenger client is that it allows you to have Genstat running remotely on an network contactable machine.
You can configure the Genstat server host and port via environment variables:
    ```{r}
    Sys.setenv(GENSTAT_HOST = "sc389508.UoA.auckland.ac.nz")
    Sys.setenv(GENSTAT_PORT = "8085") 
    knitr::knit_engines$set(gs = gsengine::gs.engine())
    ```
or you can specify the host and the port in the call to `gs.engine`
    ```{r tidy=FALSE}
    knitr::knit_engines$set(gs = gsengine::gs.engine(host = "sc389508.UoA.auckland.ac.nz", 
                                                     port = 8085))
    ```
Note that the default host is `localhost` and the default port is `8085` so we did not really need to specify the port.

## Writing Genstat chunks
To **run Genstat code** in your R Markdown file, you need to mark your chunk as with the same name you used to set the engine for `knitr`. So we used the name `gs`, and that means we can *mark* Genstat chunks with 

    ```{gs}
    
    ```

## Doing some simple things with Genstat

### Simple `PRINT` statements
We can ask Genstat to print something for us:

```{gs}
PRINT 1.0
```

This code will be sent to the Genstat server, and any output will be captured and rendered in the final document.
That of course is very exciting. We can make it next level exciting by declaring a variable and printing it.

Example:
```{gs}
VARIATE [VALUES=1,2,3] Foo
PRINT Foo
```

### More complex code execution
We are unlikely to want to use a programme with Genstat's capabilities simply to print things out. It is much more likely that we want to do some statistical analysis and capture the output in our report. As an example we will analyze the built-in Wheat Trials data set. It contains information from a crop trial in New Zealand with four different cultivars.

```{gs}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```



### Displaying Genstat Graphics
Any reproducible research of course needs to be able to reproduce statistical graphics and, if you are working with Genstat, then it is highly likely you will want to be able to use Genstat's graphics system. 

If Genstat outputs a **PNG image**, it will be displayed directly in the output document. These images are saved locally with filenames like 'img_1.png', 'img_2.png', etc.

Example:
```{gs}
DGRAPH !(1,2,3,4,5); !(10,15,7,20,12)
```

## Echo-only Code Blocks

1) If you want to display the Genstat code **without evaluating** it(eval=FALSE):
    
    {gs, eval=FALSE}
  
    Example:
    
    ```{gs, eval=FALSE}
    PRINT 'This should not run.'
    ```


2) By default, the 'gs.engine' **does** show the Genstat commands submitted in each chunk.

    To **hide Genstat code lines** in the rendered output, use the 'echo = FALSE' option in the chunk header: 
    
    {gs, echo=FALSE}
  
    Example:
    ```{gs, echo=FALSE}
    PRINT 'This should run.'
    ```

    This will only include the Genstat result or tables in the final document output.

    This setting behaves similarly to R Markdownâ€™s native echo = TRUE option for R code chunks.







# Warning and Table Formatting
The 'gs.engine' will automatically:

1) **Highlight Genstat warnings/Faults** in red.

2) **Format complex tables** (like factors/variates) as Markdown tables.

3) **Format simple tables** (like value/rank summaries) as well-structured Markdown tables.

4) **Recognize and format structural markers** in Genstat output for better readability:
  
    -Section breaks such as 1., 2., or 3.1 are rendered as Markdown section dividers:---

    -Headings indicated by === (equal signs under a line) will be converted into bold headings.

    -Subheadings indicated by --- (hyphens under a line) will be converted into italicized subheadings.

    Example:
```{gs, store_complex_tables=TRUE, store_simple_tables=TRUE}
IMPORT '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
AMCOMPARISON Cultivar
ANOVA [FPROB=yes; PSE=LSD] Yield_14%_t_ha_adj
AMCOMPARISON Cultivar
```




# Troubleshooting
If you experience connection issues:

1. Ensure your Genstat socket server is running and listening on the correct port.

2. Test using 'telnet <host> <port>' or similar tools.



# Session Info
```{r}
sessionInfo()
```

