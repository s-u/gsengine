---
title: "Using gs.engine(): Genstat Socket Engine"
author: "Yuxiao Wang, James Curran, Simon Urbanek"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    fig_caption: true
vignette: >
  %\VignetteIndexEntry{Using gs.engine(): Genstat Socket Engine}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{css, echo = FALSE}
img {
    max-width: 50%;  
    height: auto; 
}

/* Strip borders/striping that html_vignette adds */
table.GenTable,
table.GenTable th,
table.GenTable td {
  border: none !important;
  background: none !important;
}
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```



## Overview
This vignette demonstrates how to use the `gs.engine` function provided by the `gsengine` package to run Genstat code chunks from within an R Markdown document.

It assumes:

  * You have a Genstat licence
  * A *listening programme*---Genstat messenger is already running and accessible, either locally, or over a socket connection
  
## Using `gsengine` with Genstat on your own machine
If you have Genstat installed locally, i.e. on the machine that you are writing your R Markdown document, then you can create a `knitr` engine for interacting with Genstat by using the `gs.engine` function from the `gsengine` package with the `knitr::knit_engines$set` function. That is, you create an R chunk that calls the `knitr::knit_engines$set` function

````{r eval=FALSE, highlight=FALSE}
```{r}
knitr::knit_engines$set(gs = gsengine::gs.engine())
```
````
Note that there is nothing special about the `gs` variable. All it allows you to do is tell R Markdown that the chunk should talk to Genstat in order to interpret the code. That is if you specify a chunk with

````{r eval=FALSE, highlight=FALSE}
```{gs}
```
````
then R Markdown knows to talk to the Genstat engine. We could have used the name `Genstat`, `g`, or any other valid variable name and it would work in the same way. We will use `gs` throughout this document.

## Interacting with Genstat remotely
One of the cool things about how David Baird and Simon Urbanek wrote the Genstat Messenger client is that it allows you to have Genstat running remotely on an network contactable machine.
You can configure the Genstat server host and port via environment variables:
````{r eval=FALSE, highlight=FALSE}
```{r}
Sys.setenv(GENSTAT_HOST = "sc389508.UoA.auckland.ac.nz")
Sys.setenv(GENSTAT_PORT = "8085") 
knitr::knit_engines$set(gs = gsengine::gs.engine())
```
````
or you can specify the host and the port in the call to `gs.engine`
````{r eval=FALSE, highlight=FALSE}
```{r tidy=FALSE}
knitr::knit_engines$set(gs = gsengine::gs.engine(host = "sc389508.UoA.auckland.ac.nz", 
                                                 port = 8085))
```
````
Note that the default host is `localhost` and the default port is `8085` so we did not really need to specify the port.

## Writing Genstat chunks
To **run Genstat code** in your R Markdown file, you need to mark your chunk as with the same name you used to set the engine for `knitr`. So we used the name `gs`, and that means we can *mark* Genstat chunks with 

````{r eval=FALSE, highlight=FALSE}
```{gs}
```
````
## Doing some simple things with Genstat

### Simple `PRINT` statements
We can ask Genstat to print something for us:
```{r tidy=FALSE, echo=FALSE}
#knitr::knit_engines$set(gs = gsengine::gs.engine(host = "sc389508.UoA.auckland.ac.nz"))
knitr::knit_engines$set(gs = gsengine::gs.engine(host = "localhost"))
```

```{gs}
PRINT 1.0
```

This code will be sent to the Genstat server, and any output will be captured and rendered in the final document.
That of course is very exciting. We can make it next level exciting by declaring a variable and printing it.

Example:
```{gs}
VARIATE [VALUES=1,2,3] Foo
PRINT Foo
```

### More complex code execution
We are unlikely to want to use a programme with Genstat's capabilities simply to print things out. It is much more likely that we want to do some statistical analysis and capture the output in our report. As an example we will analyze the built-in Wheat Trials data set. It contains information from a crop trial in New Zealand with four different cultivars.

```{gs}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```

### Displaying Genstat Graphics
Any reproducible research of course needs to be able to reproduce statistical graphics and, if you are working with Genstat, then it is highly likely you will want to be able to use Genstat's graphics system. 

Calls to Genstat's graphing procedures result in a PNG image, which are be displayed directly in the output document. These images are saved locally with filenames like 'img_1.png', 'img_2.png', etc.

Example:
```{gs}
DGRAPH !(1,2,3,4,5); !(10,15,7,20,12)
```

## Chunk options
Readers who are familiar with R Markdown will be aware that chunk options can be used to control how R Markdown behaves. For example, there are options to surpress evaluation, surpress code, change plot dimensions and so on. Many of these will function in the same way for Genstat code, but some may not. We give examples of some common options here, and then provide examples of some which are specific to the `gsengine` package.

### Displaying Genstat code without evaluation 
If you want to display the Genstat code without evaluating---for example if you are interested in displaying the code for instructive purposes---then the `eval` chunk option works as it does with R Markdown. That is, setting `eval=FALSE` has this consequence:

````{r eval=FALSE, highlight=FALSE}
```{gs, eval=FALSE}
```
````
Example:
    
````{r eval=FALSE, highlight=FALSE}
```{gs, eval=FALSE}
PRINT 'This should not run.'
```
````

### Hiding Genstat code
By default, the 'gs.engine' shows the Genstat commands submitted in each chunk. There will be times when you want to show the results of an analysis in Genstat, but do not necessarily need the reader to see the Genstat commands. To hide Genstat commands in the rendered output, we use the `echo=FALSE` option in the chunk header, in the same way we do in R Markdown: 

````{r eval=FALSE, highlight=FALSE}
```{gs, echo=FALSE}
```
````

Example:
````{r eval=FALSE, highlight=FALSE}
```{gs, echo=FALSE}
PRINT 'This should run.'
```
````
This will only include the Genstat result or tables in the final document output.

### Saving Genstat tables for further manipulation
A lot of Genstat output is in tabular format. Equally, it is a very common in reproducible research to want to include figures from tables. For example a sum-of-squares value or an $F$-statistic. The current implementation in `gsengine` allows for three different modes of table retrieval. The package can

- automatically assign all tables to a list to a name like gs_tables_<chunklabel>
- assign a single table (if there is only one) or a list to a given name
- return the first $k$ tables to a list of $k$ names

Here are a few examples
````{r eval=FALSE, highlight=FALSE}
```{gs, saveTables=TRUE}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```
````

```{gs, saveTables=TRUE, echo=FALSE}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```
Notice that in this example there is no label for the chunk. In this situation `gsengine` will return a list called `gs_tables_last`. This will, of course, get overwritten if you ask to save the tables in a subsequent chunk. 

```{r}
str(gs_tables_last)
```

As you can see there are still a few unresovled issues here in that we have recovered the data, but it is not neccesarily laid out in a manner we might expect. For example, you might be able access the Mean Squares in ANOVA table using a column name of `Mean.Sq` or something similar. We will return to this problem later.

We will repeat part of the last example, but using a chunk label. This is useful when you want to preserve tables from earlier chunks.

````{r eval=FALSE, highlight=FALSE}
```{gs, label="wheat_anova", saveTables=TRUE}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```
````

```{gs, label="wheat_anova", saveTables=TRUE, echo=FALSE}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```

There is a chunk label for this chunk, `wheat_anova`. In this situation `gsengine` will return a list called `gs_tables_<label>`, or specifically in this example `gs_tables_wheat_anova`. This variable will last for all of the knitr document because you cannot duplicate chunk labels.

```{r}
gs_tables_wheat_anova[[1]]
```

There are two other variants. Firstly we can just specify the name of the list. For example if we use `saveTables="wheat_anova"` then we can refer to the results with the variable `wheat_anova`. Be warned though that this is like every other variable, and can be over-written is future chunks.

````{r eval=FALSE, highlight=FALSE}
```{gs, saveTables="wheat_anova"}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```
````

```{gs, saveTables="wheat_anova", echo=FALSE}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```


```{r}
wheat_anova[[1]]
```

If there is only a single table in the output, then the variable will not be a list of `data.frames` but rather a single data frame. For example

````{r eval=FALSE, highlight=FALSE}
```{gs, saveTables="foo"}
VARIATE [VALUES=1,2,3] Foo
PRINT Foo
```
````

```{gs, saveTables="foo", echo=FALSE}
VARIATE [VALUES=1,2,3] Foo
PRINT Foo
```

Now we can access the variable `foo`. I.e.

```{r}
foo
```

The final mode of use is that we can provide a list/vector of table names for the results. 

````{r eval=FALSE, highlight=FALSE}
```{gs, saveTables=c("anovatbl", "meanstbl")}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```
````

```{gs, saveTables=c("anovatbl", "meanstbl"), echo=FALSE}
IMPORT [PRINT=*] '%DATA%/WheatTrials.xlsx'; SHEET='Trial A1'
TREATMENTS Cultivar
BLOCKS Rep
ANOVA [FPROB=yes; PSE=LSD] Mean_Population_m2
```


```{r}
str(anovatbl)
str(meanstbl)
```



# Troubleshooting
If you experience connection issues:

1. Ensure your Genstat socket server is running and listening on the correct port.

2. Test using 'telnet <host> <port>' or similar tools.



# Session Info
```{r}
sessionInfo()
```

